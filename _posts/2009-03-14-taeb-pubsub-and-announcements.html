---
title: TAEB, pubsub, and announcements
layout: post
---
<p>TAEB is a decently-sized, componentized program. Components need to be able to communicate with each other. For example, the Senses component (which tracks the state of TAEB's character) needs to know when we are indebted to a shopkeeper so that it can respond to the AI when it asks if TAEB is in debt, and for how much. The Cartographer component (which tracks the state of the dungeon map) needs to know when TAEB <i>becomes</i> indebted so it can mark the current room as a shop. In general, we want <i>any</i> component to be able to listen for <i>any</i> update. This will let us remain flexible and extensible; the completely-separate AI can listen for any update that the framework can.</p>

<p>We use the <a href="http://en.wikipedia.org/wiki/Publish-subscribe">publish-subscribe pattern</a> to control this complexity. Pubsub decouples those who generate updates (publishers) from those who listen for updates (subscribers). TAEB has been using pubsub for a long time now (since 2008-01-06, according to darcs trackdown). To publish a message, anything in the program can call <tt>TAEB-&gt;enqueue_message("foo" => @arguments)</tt>. This will call the <tt>msg_foo</tt> method on all subscribers with arguments <tt>@arguments</tt>. We have a component, Publisher, that acts as message broker.</p>

<p>Pubsub has been a great tool for letting TAEB understand messages from NetHack. We have a component that is devoted entirely to figuring out what the current state of the screen is telling us: the ScreenScraper. The ScreenScraper deals mostly with transforming characters on the screen into published messages. For example, when the NetHack prints the message "You owe (somebody) (some amount of) zorkmids.", the ScreenScraper publishes a <tt>debt</tt> message with one argument: the number of gold pieces TAEB owes. The Senses has a <tt>msg_debt</tt> method that stores this amount of debt in an attribute. The Cartographer has a <tt>msg_debt</tt> method that floodfills the current room's tiles with the shop bit. The ScreenScraper does not need to know who cares about debt. The ScreenScraper publishes a lot of messages that no component subscribes to yet, and that's okay!</p>

<p>I'm happy with this, but there is room for improvement. Simple methods are not great message handlers. There are painful bugs lurking when subscriptions interact with inheritance. Suppose the AI defines a generic "go to a specific tile" behavior. This behavior would need to handle <tt>walked</tt> so it can track TAEB's progress. This GotoTile behavior is then subclassed to produce behaviors such as GoUpstairs and GotoCorpse. GotoCorpse might need to handle <tt>walked</tt> so it can age the corpse (so that TAEB doesn't eat rotten corpses). When the publisher sends the <tt>walked</tt> message to the GotoCorpse behavior, it does <em>not</em> invoke GotoTile's <tt>msg_walked</tt> method, because GotoCorpse didn't invoke it. While you may argue that GotoCorpse <em>should</em> have known to invoke GotoTile's <tt>msg_walked</tt> as that is part of its public interface, it certainly sucks for usability. It's especially painful when GotoTile begins subscribing to <tt>walked</tt> months after GotoCorpse is written!</p>

<p>The potential fixes for this are easy. The one I like best is providing some "subscribe to a message" sugar. Where we previously wrote <tt>sub msg_walked { ... }</tt>, we would now write <tt>message walked => sub { ... }</tt>. This sugar would handle publishing to parent classes if there are any. It would still use method calls behind the scene; <tt>message</tt> would install a <tt>msg_walked</tt> method. This gives us maximum flexibility. A subscriber could define an unusual message that would only conditionally be published to its parents.</p>

<p>The arguments we pass to each method could be improved as well. It's not immediately apparent what arguments the <tt>msg_debt</tt> method would receive. Currently we pass the amount of debt. However, we should also be providing the name of the shopkeeper TAEB is indebted to. This would help the Cartographer resolve ambiguities when there are multiple rooms and shops in sight. Should we rewrite every <tt>msg_debt</tt> method (including those potentially written by third-party, unknown AI hackers) to take named parameters? Should we pass in the shopkeeper's name as the second parameter? Should we pass in the name as the <em>first</em> parameter? After all, the name does come first in the message NetHack prints. We could provide one positional parameter (amount) and one named parameter (shopkeeper). Hey wait, it would be useful to also pass which items we're buying as well...</p>

<p>The best answer is to make each message an object. We would have a <tt>TAEB::Message::Status::Debt</tt> class with attributes <tt>amount</tt> and <tt>shopkeeper</tt>. This class could have a method to ask the inventory what items are currently in TAEB's shopping cart. If we're feeling cute, we could even overload this message to stringify to the amount of debt.</p>

<p>Pubsub with objects as messages is generally called <b><a href="http://www.cincomsmalltalk.com/userblogs/vbykov/blogView?entry=3310034894">Announcements</a></b>. The concept of announcements is more general than pubsub. Announcements lets subscribers of a message communicate with the other subscribers, and even with the publisher.</p>

<p>Currently, when NetHack presents TAEB with a menu to select which items to pick up, TAEB will ask the AI whether it wants to pick up each item. The AI is asked about the item <em>without the context of the other items that it can pick up</em>. This really sucks! If TAEB is toeing the burden line, it needs to be pretty strict about what items it will pick up. This means it may refuse to pick up a useful item because there just might be an even more useful item further down the list.</p>

<p>Instead, TAEB should publish a "pick up items" announcement. This announcement, <tt>TAEB::Message::Query::PickupItems</tt>, would have the list of items. Subscribers would select which items they want by invoking methods on the announcement. When all subscribers have had a chance at it, the ScreenScraper would select the items in NetHack's menu accordingly. The selection doesn't have to be binary either; each subscriber could assign a numeric "desire" to each item. The ScreenScraper would then select items that have a sum desire greater than some cutoff (which would be another decision that some subscriber could set). Using announcements would better decouple the AI from the framework.</p>

<p>This is not the first time that turning plain strings into classes has been a major improvement for TAEB. Previously, the AI would return a string, a NetHack command, as the action to perform next. We then reified actions into classes. Letting the current action subscribe to messages, and respond to NetHack prompts, vastly improved TAEB's interactions with NetHack. Problems with unexpected prompts (such as "Eat this corpse on the ground?") quickly and completely vanished. Actions subscribing to messages lets us handle ambiguous messages better; if we just applied a unicorn horn, then we can figure out that "You feel sick." means the unicorn horn was cursed and TAEB can mark it so.</p>

<p>TAEB does not have announcements yet, but that's my next big project. I'm excited by the many possibilities here.</p>
